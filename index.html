<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Regrecall&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Regrecall's Home">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Regrecall's Home">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Regrecall's Home">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Regrecall&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Regrecall&#39;s Home</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Don&#39;t lose your heart</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/16/hello-world/" class="article-date">
  <time datetime="2015-08-16T15:08:57.000Z" itemprop="datePublished">2015-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/16/hello-world/" data-id="cieptkbdb00031p04ayag5jdj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-in-action-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/30/kafka-in-action-1/" class="article-date">
  <time datetime="2015-03-30T13:43:15.000Z" itemprop="datePublished">2015-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/30/kafka-in-action-1/">Kafka In Action 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Kafka_简介">Kafka 简介</h1><p>准备写一个Kafka系列，用于了解分布式消息系统的架构。<br>在大数据的时代, 所有的信息都是有用的(用户行为data, 应用性能记录，日志文件，事件消息等等)，所以相应的对于消息中间件也产生其他的需求：<br>a. 基本保证，需要持续化消息，任何消息都不能丢失，并且可以存储大量的消息。<br>b. 面对大量的client，可以支持相当高的并发查询和写入<br>c. 分布式部署，可以横向扩展<br>d. 实时性，producer产生了消息，consumer必须立刻可以查看。</p>
<p>针对这样的一些需求，Kafka就孕育而生了。下面kafka简单消费者生产者的图</p>
<img src="/images/kafka_producer_consumer.png" class="center" width="380" height="320">
<h1 id="Kafka_Architecture">Kafka Architecture</h1><p>首先简单介绍Kafka几个关键的组件：</p>
<p><strong>Topic</strong>: topic可以简单理解消息的一个分类, producer发送消息和consumer消费消息都会依赖这个topic, topic可以分为多个partition, partition可以理解一个topic消息的量太大，对它进行拆分，这样就可以提高并发消费的能力。</p>
<p><strong>Broker</strong>: 一个kafka的集群含有多个server, 每个server就含有一个或者多个broker, 每次topic的创建都会有与broker相关，每次produer发布消息和consumer消费消息都会跟broker打交道。</p>
<p><strong>Producer</strong>: Produer发布消息针对某个topic，会选择这个topic里面的一个合适的partition，进行发送。</p>
<p><strong>Consumer</strong>: Consumer就是注册某个topic, 然后接受发布的消息</p>
<p><strong>ZooKeeper</strong>: ZooKeeper用来协调Broker和consumers, 并且管理broker和consumer存活。</p>
<p>kafka可以部署多种cluster模式：</p>
<ul>
<li>单个节点 —&gt; 单个broker cluster</li>
<li>单个节点 —&gt; 多个broker cluster</li>
<li>多个节点 —&gt; 多个broker cluster</li>
</ul>
<img src="/images/kafka-architecture.png" class="center" width="380" height="320">
<h1 id="Kafka_重要模块简介">Kafka 重要模块简介</h1><h2 id="Partition">Partition</h2><p>首先来看看重要的Partition,<br>针对Kafka的topic, Partition就是map到的一个逻辑log，这个log由多个segment file组成的，每个partition都含有有序的，一组不可变的消息。当一个消息从producer发送到partition的时候，broker就会把这个message加到最后一个segment里面。当达到了一定message的时候或者一定的时间，就会把segment flush到磁盘，一旦segment被flush了，这时候consumer就可以去消费了。<br>所有Partition里面的message, 都被赋值了一个offset, 用来唯一标识一个message在partition里面. </p>
<p>每个Partion可以配置多个replicated在多个server间用来做fault tolerance.<br>每个Partition要么充当着 leader, 或者 充当着 follwers的角色，leader就全心全意地负责读写请求，然而follower则是异步地从leader那边同步信息过来。<br>Kafka动态维护一个ISR(in-sync replicas)的集合，这种ISR里面partition几乎都是和leader同步，如果follower挂掉了或者没有跟leader及时同步，则会从in-sync里面移除。<br>当一条消息提交，意味着所有in-sync里面的follwoer都同步了，这意味着无需担心leader挂掉，数据丢失的情况。当然producer是可以选择是否等待消息提交。<br>当leader当掉的时候，在ISR里面的follower就会自动变成新的leader，这个ISR的信息就是维护在zookeeper里面的，zookeeper随时监控着这些partition的生存情况。</p>
<h2 id="Consumer">Consumer</h2><p>Kafka Consumer的设计根据传统的消息平台consumer, consumer group都一样。<br>每个topic的消息都会被一个consumer groups里面的consumer消费，意识说一个consumer group里面有多的consumer的时候，只会有一个consumer接受到一个topic消息。如果想要一个topic的消息被多个consumer消费，那么这个consumer需要在不同的consumer group里面。</p>
<p>consumer总是从一个特定的partition里面顺序的消费，然后保存一个offset，来显示这个consumer消费了多少的消息。根据Kafka的设计，broker是无状态的，所以任何消费的信息都是保存在consumer端的，broker并不保存这条记录被谁消费。<br>所以Kafka有以下三种消息保证：</p>
<ul>
<li>消息不会被重发，但是可能丢失</li>
<li>消息可以能被重发，但是绝不丢失</li>
<li>消息且只会被发送一次</li>
</ul>
<p>假设consumer处理消息分为三个阶段，读取消息，处理消息，然后保存更新offset,<br>那么我们看下第一种情况，consumer接受到了消息，然后更新offset, 在没有处理消息前就crash掉了，接着另外一个consumer来接受的时候，发现offset已经被更新，然后就去取下一条消息，这时候上一条消息就被丢弃了。第二种情况，consumer同样接受到了消息，但是先去处理了消息，但是在没有保存offset之前就crash掉了，接着另外一个consumer来接受的时候，发现offset还是以前那个，这时候就会再去拉取一次，这样就造成了重复投递了。第三种情况，其实保证处理消息和更新offset在同一个事务中，这时候就可以保证只会投递一次。</p>
<h1 id="Summary">Summary</h1><p>简单介绍了Kafka的架构，以前我最搞不懂的是，如何做到replication, 只要明白kafka的replication是针对partition的，而且是ISR进行leader, follower的同步，并且整个kafka的并发能力取决于partition的个数.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/30/kafka-in-action-1/" data-id="cieptkbdf00041p042kt5cqxz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-concurrency-concurrentskiplistmap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/16/java-concurrency-concurrentskiplistmap/" class="article-date">
  <time datetime="2015-03-16T15:18:25.000Z" itemprop="datePublished">2015-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/16/java-concurrency-concurrentskiplistmap/">从零单排 Java Concurrency, SkipList&amp;ConcurrnetSkipListMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="感概">感概</h1><p>好久没有写博客，自从上次已经有7,8个月了吧，在7,8个月里面接触的东西，学习到的东西也挺多的，由于没有写博客，或者是缺少总结的原因，很多东西都慢慢地遗忘了。还有就是时间确实不够，时间从来就没有够过。不管了，从这次开始要慢慢地拾起这些东西，慢慢地做出些改变。</p>
<h1 id="概述">概述</h1><p>这次给大家带来的 ConcurrentSkipListMap, 首先它是一个线程安全的Map, 这个就类似于ConcurrentHashMap, 可以用于并发的场景，其次它保证了绝大多数操作都在O(log(n))之类完成，并且它还保证<br>存储的顺序，可以设置Comparator来做Key的排序，这些好处都来源于 Skip List, 俗称跳表。</p>
<h1 id="跳表介绍">跳表介绍</h1><p>Skip List是 <a href="http://en.wikipedia.org/wiki/William_Pugh" target="_blank" rel="external">William Pugh</a>在1989年创建出来的(又见一个位神牛), 主要的目的就像他描述的那样，是用来替代平衡树的。跳表是一种随机性的数据结构，相对于平衡树来说，跳表更加的简单，能一口气实现红黑树,AVL这样的平衡树的人，还是太少了，而且内部确实复杂，调试, 用起来太麻烦。<br>同样跳表还可以做到平衡树那样的查找时间，特别是在并发的场景下面，由于红黑树的插入或者删除会做rebalance这样操作，那么影响的数据就会变多，锁的粒度就变大。但是跳表的插入或者删除操作影响的数据会很小，锁的粒度就会小，这样在大数据量的情况下，跳表的性能自然就会比红黑树要好。</p>
<h1 id="跳表细节">跳表细节</h1><p>先看下面这张图：</p>
<img src="/images/skip_list.jpg" class="center" width="380" height="320">
<p>这就是一个跳表，看图说话可以得到的是底部是含有所有元素的链表，并且是有序的。<br>设想我们如果需要在一个有序的链表上查找一个数，一般的做法就是顺序遍历一下列表，然后拿查找的元素来比较各个存在元素，时间复杂度为O(n)</p>
<p>后来二分查找出现了，先选取中间的元素来判断，如果大于就抛弃左边的，直接进入右边进行比较，时间复杂度为O(logn).<br>其实跳表也是利用了这样的特性(找出一个合适的值来跟当前值进行比较，不一定就是中间值)，概率性抽取一部分数字提取出来，优先做比较，假设这个概率为p, 抽取一层过后，又抽取一层，直到最后只剩首元素和最后的NIL.<br>就像上图一样：<br>a.  我们有 20， 30， 40， 50， 70， 90 这样的数组<br>b.  假设P等于1/2概率, 就只有40, 70, 90中奖了，有幸升级了<br>c.  又来一次1/2概率, 就只有40中奖，有幸升级<br>d.  再来一次1/2概率, 40不幸没有升上去，这时候就到顶了。</p>
<p>那么来看下查找的过程是怎么样的<br>假设我们需要查找70，步骤如下：</p>
<ul>
<li>首先从Top层出发，70 &gt; 20, 并且 70 ！= NIL, 继续往下查找</li>
<li>到了第2层的20，然后发现 70 &gt; 20, 这时候往右走，来到40的节点，<br>70 &gt; 40, 但是70 ！= NIL，继续往下查找</li>
<li>到了第3层的40，然后发现70 &gt; 40, 继续往右边走，这时候来到 70，发现 70 = 70，查找结束。</li>
</ul>
<img src="/images/skip_list_search.jpg" class="center" width="380" height="320">
<p>经过一堆长串公式得到，跳表的查找时间复杂度为 O(log(n)).</p>
<p>跳表的插入，其实整个插入的过程跟查找的过程类似，不一样的是，插入的元素肯定会出现在底部的链表中，所以当确定了插入的位置后，这时候会有个叫做“Coin Flip”的过程，丢硬币，就是根据概率公式(求出P那个)，那计算下这时候这个新的节点需不需要往上”升级”, 如果需要就往上升，不需要就算了。重复这个”Coin Flip”的操作，直到不”升级”，当然升级上去之后，也需要和当前这一层的元素前后连接起来。</p>
<p>删除操作，类似先找到该元素，然后把它和它上层的元素都进行删除。<br>不像平衡树一样，跳表并不能保证查找的最坏情况，而平衡树却保证最坏也是O(logn),<br>确实有可能性，coin-flips的过程会让跳表产生不平衡的结构，但是这种情况只有要”<br>被到家”才发生，并且在实际情况下，大家都会选择如此简单的跳表而不是平衡树。</p>
<p>跳表也有一些O(n)的操作，强制我们去遍历一次整个表，例如打印所有元素呀，算下size()之类的。</p>
<h1 id="ConcurrnetSkipListMap的实现">ConcurrnetSkipListMap的实现</h1><p>其实ConcurrentSkipListMap的实现就是实现了一个无锁版的跳表，主要是利用无锁的链表的实现来管理跳表底层，同样利用CAS来完成替换。以后会带来无锁的设计实现。</p>
<h1 id="Summary">Summary</h1><p>简单介绍了跳表设计思想和应用，以及在高并发的情况下，优于平衡树的原因，所以跳表在并发计算领域出现了，redis, leveldb都用应用，并且在分布式里面可以利用跳表的无锁特性来实现优先级队列。跳表其实也是一种利用空间换取时间的方法，所以这里P 概率的选择，至关重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/16/java-concurrency-concurrentskiplistmap/" data-id="cieptkbdj00071p04lhwdjukx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wait-notify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/24/wait-notify/" class="article-date">
  <time datetime="2014-06-24T10:57:15.000Z" itemprop="datePublished">2014-06-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/24/wait-notify/">从零单排 Java concurrency, wait &amp; notify</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="wait_&amp;_notify_基础">wait &amp; notify 基础</h1><p>今天给大家介绍下Java里面常用的wait和notify, wait, notify是java最基本的Object class里面的方法，<br>允许线程里面进行通信，简单来说wait就是让线程进入sleep状态，然后notify就是让前面那个线程被唤醒，继续执行。<br>下面我们来看看这样一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mutex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(Object mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Start wait"</span>);</span><br><span class="line">                mutex.wait();</span><br><span class="line">                System.out.println(<span class="string">"End wait"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mutex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notifier</span><span class="params">(Object mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Start notify"</span>);</span><br><span class="line">                mutex.notify();</span><br><span class="line">                System.out.println(<span class="string">"End notify"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line">    Waiter waiter = <span class="keyword">new</span> Waiter(mutex);</span><br><span class="line">    <span class="keyword">new</span> Thread(waiter).start();</span><br><span class="line">    Notifier notifier = <span class="keyword">new</span> Notifier(mutex);</span><br><span class="line">    <span class="keyword">new</span> Thread(notifier).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家来看看，这段的输出是什么呢？ 相信大家肯定知道是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start wait</span><br><span class="line">Start notify</span><br><span class="line">End notify</span><br><span class="line">End wait</span><br></pre></td></tr></table></figure>
<p>大家知道为什么吗？ 接下来为大家剖析下具体做的事情</p>
<h1 id="Wait">Wait</h1><h2 id="找到你的wait方法">找到你的wait方法</h2><p>首先我们肯定找到了Object.java里面的wait方法，然后发现它是一个native方法，接着我们就到了JVM里面去了，<br>Object.c里面，发现原来是这样的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接着就我们就追踪到了Jvm.cpp里面，找到这个JVM_MonitorWait这个函数指针，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_MonitorWait"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle)</span>)</span>; <span class="comment">//定义一个Thread handler</span></span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">"JVM_MonitorWait must apply to an object"</span>);</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;  <span class="comment">//改变这个线程的状态</span></span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_monitor_wait()) &#123;</span><br><span class="line">    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectSynchronizer::wait(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p>
<p>关键来了，wait调用的是ObjectSynchronizer::wait这个方法，我们来看看这个方法做了些什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::revoke_and_rebias(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    TEVENT (wait - <span class="keyword">throw</span> IAX) ;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj());  <span class="comment">// 1</span></span><br><span class="line">  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);		<span class="comment">// 2</span></span><br><span class="line">  monitor-&gt;wait(millis, <span class="literal">true</span>, THREAD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This dummy call is in place to get around dtrace bug 6254741.  Once</span><br><span class="line">     that's fixed we can uncomment the following line and remove the call */</span></span><br><span class="line">  <span class="comment">// DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);</span></span><br><span class="line">  dtrace_waited_probe(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这里标注的第一步很重要，通过ObjectSynchronizer::inflate方法找到objectMonitor, 就是你的wait调用的这个object对应的monitor, 然后调用monitor的wait方法来进行真正的wait操作。<br>这个方法有点长，我就不贴代码了，把重要的步骤列出来:</p>
<ul>
<li>CHECK_OWNER(), 这个宏就是你为什么会得到IllegalMonitorStateException的原因，如果你写wait的时候，<br>写出下面代码会报错的原因。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WaitTest wt = <span class="keyword">new</span> WaitTest();</span><br><span class="line">    wt.waitFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这就是为什么wait，notify之前必须要获得锁的原因，代码里面有这样的判断if (THREAD-&gt;is_lock_owned((address) _owner))，<br>当前线程必须先有这个object锁，才能玩下去，不然就会抛出这样的IllegalMonitorStateException。</p>
<ul>
<li>addWaiter, 这是wait里面重要的一步，把构造好的ObjectWaiter加入等待队列里面去<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ObjectWaiter node.</span></span><br><span class="line"><span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">node.TState = ObjectWaiter::TS_WAIT ;</span><br><span class="line">Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">OrderAccess::fence();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入等待队列，这里等待队列可以是循环双向链表，可以是优先级队列也可以是其他数据结构</span></span><br><span class="line">WaitSetLock用来保护这个waiting <span class="built_in">queue</span>的.</span><br><span class="line">Thread::SpinAcquire (&amp;_WaitSetLock, <span class="string">"WaitSet - add"</span>) ;</span><br><span class="line">AddWaiter (&amp;node) ;</span><br><span class="line">Thread::SpinRelease (&amp;_WaitSetLock) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里要介绍下这里waiter的队列，里面保存的是所有wait在这个monitor上的线程，叫做 ObjectWaiter * volatile _WaitSet;</p>
<ul>
<li>exit monitor, 当我们已经把等待线程加入等待队列之后，我们就可以退出了.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_waiters++;                  <span class="comment">// increment the number of waiters</span></span><br><span class="line">_recursions = <span class="number">0</span>;             <span class="comment">// set the recursion level to be 1</span></span><br><span class="line"><span class="built_in">exit</span> (Self) ;                    <span class="comment">// exit the monitor</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>里面完成了件很重要的事就是释放当前这个object的锁，只有这样外面的除了wait线程外的其他线程才有可能得到这个锁，进而<br>进行其他操作。</p>
<ul>
<li>park 当前线程，已经做完了准备工作，那么就是时候把当前线程挂起了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (millis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   Self-&gt;_ParkEvent-&gt;park () ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ret = Self-&gt;_ParkEvent-&gt;park (millis) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个park的实现就跟各个操作系统实现相关了，目的是一样的就是把当前线程挂起，底层主要是用pthread_cond_wait，来实现挂起当前线程。</p>
<h1 id="Notify">Notify</h1><h2 id="找到相应的Notify函数">找到相应的Notify函数</h2><p>类似于上面的wait, 从Object.c 到 Jvm.cpp, 再到ObjectSynchronizer.cpp, 最后我们又来到熟悉的ObjectMonitor-&gt;notify,来看看我们notify到底做了哪些？</p>
<ul>
<li><p>首先从当前等待的队列里面，取出第一个等待的线程，  ObjectWaiter * iterator = DequeueWaiter().</p>
</li>
<li><p>然后我们就必须要介绍下，2个数据结构_EntryList 和 _cxq, _cxq是一个objectmointor的链表，把哪些最近需要获取该锁而被<br>block住的线程放到这个链表，_EntryList, 也是一个objectmonitor的链表，比起_cxq只是存放的objectmonitor被block住的时间要长些。<br>他们2个意义在于，存放的是所有等待取得这个对象锁的线程，简单来说就是该被唤醒的线程。</p>
</li>
</ul>
<p>这时候我们notify的实现就要分策略，其实策略有4种，目的都是把刚刚取出来的waiter线程，封装成objectmonitor，放进_EntryList和_cxq。</p>
<p>就在这里，其实我们并没有唤醒等待线程，只是把这个等待线程加进了需要唤醒的队列。那我们在哪里唤醒他的呢？</p>
<h2 id="唤醒等待线程">唤醒等待线程</h2><p>其实在我们sychronized 同步块，退出的时候，其实我们是调用了monitorexit的，同步块其实进入和退出都是有方法调用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">monitoerexit</span><br></pre></td></tr></table></figure></p>
<p>来我们看看monitorexit做了些什么事情，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj()</span>)</span>;</span><br><span class="line">         ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在这个ObjectSynchronizer::slow_exit里面我们就发现，其实又是调用的ObjectMonitor的exit方法，<br>跟我们第一次wait调用不一样的是，这次我们_EntryList或者_cxq里面是有唤醒的线程的，所以会去找到<br>需要唤醒的线程，然后unpark他就行了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor::ExitEpilog (Thread * Self, ObjectWaiter * Wakee) &#123;</span><br><span class="line">          ParkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line">          ....</span><br><span class="line">          DTRACE_MONITOR_PROBE(contended__exit, <span class="keyword">this</span>, object(), Self);</span><br><span class="line">          Trigger-&gt;unpark() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Summary">Summary</h1><p>这篇博客给大家带来了wait, notify的实现，让大家深刻明白，为什么wait, notify之前需要获得锁，<br>为什么wait完成之后会释放锁，希望给大家带来帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/06/24/wait-notify/" data-id="cieptkbdl00091p047u6mkpdp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-synchronized-and-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/12/synchronized-and-lock/" class="article-date">
  <time datetime="2014-05-12T09:08:18.000Z" itemprop="datePublished">2014-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/12/synchronized-and-lock/">从零单排 Java Concurrency, Synchronized and Lock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一篇给大家带来的是并发编程里面用的基础的2个东西，Synchronized 和 Lock, 他们两个都是提供了锁的能力</p>
<ul>
<li>当一个线程正在操作这个锁的时候，其他线程只能等待，排他性</li>
<li>当一个线程完成了操作，其他执行Happen-before原则，保证可见性.<br>那他们有什么不同呢，还有那些特点呢？首先我们先来看下Sychronized</li>
</ul>
<h1 id="Sychronized">Sychronized</h1><p>我们最常用的Sychronized的地方, 就是同步方法和同步块，当一个线程进入同步区域的时候，会自动获得这个锁，当它离开同步区域的时候，就会释放掉这个锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步方法，当作用在实例方法时，锁是加在当前的instance(this)上面的，当作用在静态(static)方法时，锁是加在class上面的，所以是有可能并行的进入Java实例同步方法和静态同步方法的。<br>同时Sychronized是可以重入的，所以当我们在同步方法里面调用同一个锁的另外一个同步方法时，当前线程是可以直接进入这个同步方法，而不需要重新再去请求这个锁。下面我们来看看同步块的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>不难看出这样做的好处在于减小了锁的粒度，当我们只是对于方法的小部分进行同步的时候，没有必要去把整个类实例锁住，<br>我们要做的是，申请一个新的实例，用它来锁住我们方法里面的需要同步的区域。</p>
<h1 id="Lock_VS_Sychronized">Lock VS Sychronized</h1><p>基本上你用得到Sychronized的地方，都可以用Lock的，所以我们这里就直接以对比的方式来介绍下Lock.</p>
<h2 id="更灵活结构">更灵活结构</h2><p>当我们用Sychronized的时候，要求了获得和释放锁都是必须在block结构里面，所以语法上，必须是在同一个范围内，<br>Lock就不一样了，Lock.lock() 获得锁，和 Lock.unlock() 释放锁是可以不在同一个范围内的，就像Api文档里面说的例子一样，<br>在某些算法里面，并行的遍历某些节点的时候，先lock 节点A, 节点B, 然后 release 节点A, 再lock 节点C, 这样的需求，<br>以Sychronized那种块式结构是无法完成。<br>Lock增加灵活性，总会是有代价的，这个代价就是我们失去自动释放锁的能力，我们必须自己来释放锁, 最好是用try-finally来确保你的锁能够得到释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> capacity - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="公平性">公平性</h2><p>Sychronized是没有保证线程进入同步块的顺序的，所以就可能导致饥饿的产生，有些线程一直都在等待，因为有其他线程都抢在它之前进入了同步块。其实要做到公平，原理也很简单，只要每次调用lock的时候，把当前线程保存起来，在唤醒的时候，通过一定的算法<br>选择适当的线程唤醒就可以了。Lock就是公平的，下面是RenetrantLock的构造函数，我们可以看到它接受一个是否公平的参数，来决定是否用公平策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock(<span class="keyword">boolean</span> fair)</span><br><span class="line">Creates an instance of ReentrantLock with the given fairness policy.</span><br></pre></td></tr></table></figure></p>
<h2 id="中断的能力">中断的能力</h2><p>Sychronized当一个线程进入同步块之后，我们是不能控制的，死锁或者饥饿，我们都是没有办法处理的，<br>Lock就提供了中断的能力，lockInterruptibly，trylock的函数，让我们更能控制我们的锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(time, TimeUnit.MILLISECONDS))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 确保最后释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 已经有人获得这个锁了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="读写锁">读写锁</h2><p>Sychronized, 保证同一时间只有一个线程能够进入同步局域，如果想要并发的读取同步局域的资源，<br>也是不行的，你必须要等待其他线程释放这个锁才行。这时候读写锁就产生了，ReadWriteLock, 他能让对个读的线程<br>并发的进入同步区域。</p>
<p>下面是Lock package里面的各个类的依赖关系<br><img src="/images/648-374Lock.jpg" class="center" width="600" height="300"></p>
<h1 id="Summary">Summary</h1><p>这里对比了Sychronized和Lock的差异，一般简单的锁，我们就直接运用Sychronized就可以，如果为了公平，中断，读写的能力<br>我们就可以用Lock来给我们进行保证。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/05/12/synchronized-and-lock/" data-id="cieptkbdo000b1p04br8pvv8r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-concurrency-threadpoolexecutor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/19/java-concurrency-threadpoolexecutor/" class="article-date">
  <time datetime="2014-04-19T08:16:49.000Z" itemprop="datePublished">2014-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/19/java-concurrency-threadpoolexecutor/">从零单排 Java Concurrency, 线程池, ThreadPoolExecutor实现与用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇executor framework介绍了简单的线程池的东西，这篇主要介绍ThreadPoolExecutor的使用和实现.</p>
<p>#ThreadPoolExecutor的使用<br>Java给我们提供创建线程池的方法，通常可以通过Exectuors的factory方法，newSingleThreadExecutor,<br>newFixedThreadPool, newCachedThreadPool供我们使用，但是你如果想根据你的需求自定义下自己的线程池，<br>那么你就要看看ThreadPoolExecutor，其实上面这些通过factory方法同样是创建的ThreadPoolExecutor，只是预先帮我们定制好了参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></p>
<p>线程池处理的是我们提交的task, 虽然Executor framework, 把task提交跟处理task逻辑解耦开了，但是对于提交给<br>线程池的task, 我们仍需要注意， 因为他们确定了我们线程池的配置和实现。我们尽量要保证task的隔离性或者说独立性，<br>举个例子，假设这些task之间有些依赖，task a 依赖于task b的一个结果，task a 先被加入了线程池，然后有一堆任务同时<br>也加入了线程池，同时我们线程池的size是固定了，那么会产生什么结果呢？如果运气好，我们task b会被加入队列里面，<br>进行等待，等其他任务的线程完成，然后再来处理他，可是这段时间内, task a的线程就只有等待。运气不好，直接拒绝到task b<br>的提交，那么我们task a就永远的等待下去了，一直消耗着我们资源。</p>
<p>对于线程池而言，目的是为了复用线程，减少线程创建和销毁的开销，那么我们必须要为它来个size,<br>如果是无限的，线程池就没有启到它应有的作用(newCachedThreadPool除外哟)。确定size的大小也是一门学问。<br>太大了，只会导致线程去竞争少量的CPU和内存资源，太小了，那就是对于资源的一种浪费。<br>首先我们需要了解是你所要应用的场景，还有你的task, 一般我们都已cpu核数为基础，进行一些计算，<br>如果你的task包括一些I/O，或者是一些阻塞的操作，这时候你的线程数就可以高于cpu, 一般我喜欢配置<br>cpu核数 * 2， 在Java-Concurrency-in-Practical里面给出了一个公式，大家有兴趣可以参考下，<br>除了cpu资源，还会有其他资源也限制了线程池的大小，比如数据库连接，加入每个任务都需要一个数据库连接，<br>这样线程池的大小就受制于数据库的连接数了。</p>
<p>所以当你配置ThreadPoolExecutor时，你一定要了解你要用它处理什么样的task, 以及你所部属的环境，这样你才有可能最大<br>化线程池的好处。</p>
<ul>
<li>corePoolSize, maximumPoolSize,  corePoolSize表示当没有task需要执行时，我还需要留多少线程在我的线程池里面，<br>当一个新的任务提交时，如果当前poolSize &lt;　corePoolSize时，就算有其他闲置的线程，也会创建新的线程来处理这个新任务的。<br>maximumPoolSize, 是用来表明一个时间点，最多有多少线程可以存活。 当poolSize &gt;　corePoolSize, 但是 poolSize &lt; maximumPoolSize，并且task的队列已经满了，这时候就会创建个新的线程来处理的新的任务。</li>
<li>keepAliveTime, TimeUnit, 当poolSize &gt;　corePoolSize时，超过的线程已经是闲置的，并且存活时间超过了这里设置的KeepAlive的时间，<br>我们就会把这些线程回收，当设置了allowCoreThreadTimeOut(boolean)，那么包括corePoolSize里面的线程，如果闲置同样也会被回收。</li>
<li>workQueue，用来保存我们提交的任务，主要有三种类型的queue, 一种是直接转移型，就是SynchronousQueue，这个队列并不保存任务，<br>直接把任务提交给线程，当没有线程来处理新提交的任务时，那么提交任务这个操作就会失败。还有就是有界和无界的队列，这里要特别注意的<br>是无界的队列(LinkedBlockingQueue), 如果队列里面堆积了很多任务时，一定要注意，因为这样很有可能会影响系统的性能。</li>
<li>threadFactory，用来创建线程用的，好的编程实践是对于线程池的线程命名，这样的就可以方便调试时候查看。推荐下<br>guava的做法，ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(“mypool-thread-%d”).build();</li>
<li>RejectedExecutionHandler, 当Executor已经shut down了，或者是有限的queue达到限制和线程已经创建了maximum，<br>这时候我们就需要我们的RejectedExecutionHandler了，主要有这样几种策略，直接抛出RejectedExecutionException异常(default ThreadPoolExecutor.AbortPolicy)，简单的丢弃(ThreadPoolExecutor.DiscardPolicy)，<br>丢弃最老的那个任务( ThreadPoolExecutor.DiscardOldestPolicy)，还有一种就是你的main thread去跑你提交的任务(ThreadPoolExecutor.CallerRunsPolicy)。</li>
</ul>
<p>#ThreadPoolExecutor源码分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就从execute方法入手，看看ThraedPoolExecutor是怎么实现的。首先介绍下poolSize，它表示当前线程的个数，然后我们再看看<br>addIfUnderCorePoolSize的代码，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>细心的观众，发现这段代码作用就是用来创建线程，当poolSize &lt; corePoolSize的时候，这个函数就一直返回true，创建线程成功，否者就是false，创建失败。<br>那么回到execute里面的if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))其实主要作用就是创建线程当poolSize &lt; corePoolSize的时候，<br>如果大于，就不用创建。接着就是workQueue.offer(command)，把我们提交的任务往队列里面插入，offer这里就是保证了如果满的时候，就offer失败，否者就成功，如果失败了，就会去addIfUnderMaximumPoolSize(command)，观众应该已经猜到了它的作用就是当poolSize &lt; maxiumnPoolSize的时候，去创建出额外的线程。细心的观众又要问了，那处理任务的逻辑又在哪里呢？答案就在我们创建的Thread时，我们把外面提交的task封装了下变成了worker.首先我们来看看worker的run方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是firstTask, 因为从execute的if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))，我们可以注意到，当我们第一次执行提交task时，其实这个if条件时返回false的，意识说我们不会workQueue.offer(command), 那么我们就要依靠我们这个firstTask，来完成我们第一个任务的执行了。从第一个以后，我们就要每次去getTask来执行，<br>所以大家可以明白线程池重用线程的原理就是创建一堆线程跑起之后，每个线程就无限循环地去workerQueue里面去取出任务来执行，<br>executor就只管把任务塞进去就行了。我们再来看看getTask();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = runState;</span><br><span class="line"><span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">Runnable r;</span><br><span class="line"><span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">    r = workQueue.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)</span><br><span class="line">    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    r = workQueue.take();</span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">if</span> (workerCanExit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>各位观众需要注意的是r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS); 有了它我们就实现了我们上面所说的当(poolSize &gt; corePoolSize || allowCoreThreadTimeOut时，我们需要回收掉我们多余的线程。</p>
<p>#Summary<br>从ThreadPoolExecutor的使用配置，我们了解到需要根据自己的需求和提交任务的特性来决定线程池的大小，策略等。然后看到了ThreadPoolExecutor的实现，让我们更深的理解了我们的配置的含义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/19/java-concurrency-threadpoolexecutor/" data-id="cieptkbdr000d1p043efufxlm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-executor-framework" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/09/java-executor-framework/" class="article-date">
  <time datetime="2014-04-09T14:49:37.000Z" itemprop="datePublished">2014-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/09/java-executor-framework/">从零单排 Java Concurrency, Executor 和 它的小伙伴</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇主要为大家带来的是Executor框架的介绍，让大家知道Executor为什么出现，我们该怎么用好它，以及Executor的一些小伙伴。</p>
<h1 id="Executor的产生">Executor的产生</h1><p>在我看来为什么会有Executor的产生，其实是随着业务的不断发展而来的，以前当我们提交任务的代码和我们处理这些任务代码逻辑简单，我们就把他们揉在一起，可是业务越来越复杂，我们有了自己的一些处理这些任务的逻辑了，就逼得我们把原来的代码差分，就有了Executor，回忆起以前做的一个objc上管理与服务器交互的transaction的内容的dispatcher, 其实是跟Executor类似，开始没有什么并发的要求, 没有什么优先级，没有什么特殊处理，没有什么超时，没有什么shutdown的时候，就是一个简单的FIFO的队列，后来慢慢加入这些策略，就产生现在的框架. Executor就是为了解耦任务提交和任务执行策略产生的.</p>
<h1 id="Executor的使用">Executor的使用</h1><p>我们首先来看看Executor的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里Executor负责的就是如何执行这些任务，我们可以直接同步串行的执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这样就失去了我们的性能，如果这个任务是一些I/O相关的操作，这样只会让CPU闲置。<br>于是我们就加入异步执行，为每个任务都分配一个线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exectuor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题又来了，因为Thread的创建和销毁代价还是挺大的，还有可能造成有大量的Thread闲置，<br>这也是一种浪费，同时也对垃圾回收也带来了压力。<br>线程池就孕育而生了，它用来管理一个装有工作线程的池子，并且实现了重用线程池里面闲置的线程，<br>还有任务的调度。Executors的工程方法给我们提供了创建这样的线程池的Executor, 这里主要对比下<br>newFixedThreadPool, newCachedThreadPool, 不同的是newCachedThreadPool里面线程池大小是不固定的，而<br>newFixedThreadPool里面的线程池大小是固定的，newCachedThreadPool中的线程空闲时间超过60s就会从线程池里面移除，而newFixedThreadPool里的空闲线程是不会被移除的。newCachedThreadPool更像个集结点(因为它的task queue的实现是用的SynchronousQueue)，消费里面的task的线程，是按需要创建的，根本停不下来呀，newCachedThreadPool适合去执行数量多但是存活时间短的任务。当然除了Executors给我们提供的Factory构造的线程池，我们也可以用ThreadPoolExecutor来配置我们自己的线程池。</p>
<h1 id="Future">Future</h1><img src="/images/executor_380_320.jpg" class="center" width="380" height="320">
<p>我们从上图可以看见ExecutorService接口继承了Executor接口，它为Executor带来的是对于Executor的生命周期的控制，实现这个接口，我们就可以shutdown我们的Executor了，还给我们带来Future。</p>
<h2 id="什么是Future？">什么是Future？</h2><p>Future代表的是一个异步计算的结果，我们可以通过方法，去判断是否计算已经结束，或者是等待他计算完成，并且得到结果。当我们每次向ExecutorServce提交一个Callable(Callable 比起 Runnable，我们可以得到返回值，并且还可以catch住Callable的exception)的时候，我们可以得到一个Future对象，这时候我们可以做一堆其他事情，然后再回来调用Future的get方法，得到这次Callable的结果。比如我们有一堆需要并行跑的一些模型，等我们提交了我们跑模型任务后，我们再做一堆其他计算，并且等待异步模型跑完的结果, 最后调用我们存下来的一堆Future对象的get方法，得到我们需要的值。看了Concurrency In Practice，才知道还有CompletionService，这样的好货色，有了它，我们就有一个BlockingQueue在Executor里面，这样对于调用者就不需要hold住Future了，只需要直接去CompletionService里面去take出来，当每个Future完成时，就直接取到，如果没有完成，就会在哪里等待。</p>
<h1 id="Summary">Summary</h1><p>这次只是向大家简单介绍了下Executor的由来和一些基本用法，以及Future一些用法，接下来的有一系列的BlocingQueue, ThreadPool池的源码分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/09/java-executor-framework/" data-id="cieptkbdu000f1p040w1ijfeg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-fianlly-return" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/05/java-fianlly-return/" class="article-date">
  <time datetime="2014-04-05T02:03:37.000Z" itemprop="datePublished">2014-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/05/java-fianlly-return/">从零单排 Java, finally &amp; return</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前几天在weibo上看到这样一个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码返回的是什么？当时想法是 finally肯定会执行，但是这个i++, 影响到的值，<br>应该不是return返回的那个i, return返回的i, 应该是放到了专门存放返回值的地方了，所以<br>这段代码返回的是0。为了更深入的研究下，是否这个问题跟reference相关，毕竟int是<br>普通类型嘛，所以我就写下了如下的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"11"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sb.append(<span class="string">"22"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>果不其然，这个返回还真的是”1122”, 而非”11”, 难道真的针对reference做了<br>处理的吗？我们先反编译一下，看看到底是做了些什么事？首先我们看看普通类型的<br>那段代码的字节码是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:   iconst_0 <span class="comment">// push "0" 这个常量到栈里</span></span><br><span class="line"><span class="number">1</span>:   istore_0 <span class="comment">// pop 栈顶的元素 "0" 到index 0里面去</span></span><br><span class="line"><span class="number">2</span>:   iload_0  <span class="comment">// push index 0里面存的 "0" 到栈顶</span></span><br><span class="line"><span class="number">3</span>:   istore_1 <span class="comment">// pop 栈顶的元素 "0" 到index 1里面去</span></span><br><span class="line"><span class="comment">// 前面这4步就完成了我们 int i = 0 这个操作。</span></span><br><span class="line"><span class="number">4</span>:   iinc    <span class="comment">// 0, 1 对于index 0里面存的值增加1, 这时候index 1里面的值为"1"</span></span><br><span class="line"><span class="number">7</span>:   iload_1 <span class="comment">// push index 1里面存的 "0" 到栈顶</span></span><br><span class="line"><span class="number">8</span>:   ireturn <span class="comment">// pop 当前栈顶作为返回值</span></span><br><span class="line"><span class="number">9</span>:   astore_2</span><br><span class="line"><span class="number">10</span>:  iinc    <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">13</span>:  aload_2</span><br></pre></td></tr></table></figure></p>
<p>先容我介绍下9-13行是在干什么，这是专门针对try-finally做的<br>exception handler, 如果在try里面发生了exception，就会直接执行finnaly的代码，<br>所以这里astore_2把expcetion存下来，然后执行我们finally的代码，最后在把exception push 出去。详情可以查看<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html" target="_blank" rel="external">Compiling finally</a></p>
<p>所以我们先抛开9-13行不看，研究下0-8行，我们就可以发现，返回值是存在index 1里面的，然而我们做的自增操作是针对的index 0里面存的值.<br>(这里介绍下每个method frame都会有一个local variable的数组，用来存放你产生的这些local variable, 这些说的index n就是指数组里面下标为n的值), 这就是为什么我们返回值是”0”的原因。<br>接下来我们看看那段reference的字节码是说呢么？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0:   new     #2; //class java/lang/StringBuffer</span><br><span class="line">3:   dup        </span><br><span class="line">4:   ldc     #3; //String 11</span><br><span class="line">6:   invokespecial   #4; //Method java/lang/StringBuffer."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">9:   astore_0 // pop 栈顶的元素 "11" 到index 0里面去</span><br><span class="line">10:  aload_0  // push index 0里面存的 "11" 到栈顶</span><br><span class="line">11:  astore_1 // pop 栈顶的元素 "11" 到index 1里面去</span><br><span class="line">12:  aload_0  // push index 0里面存的 "11" 到栈顶</span><br><span class="line">13:  ldc     #5; //String 22</span><br><span class="line">15:  invokevirtual   #6; //Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;</span><br><span class="line">18:  pop      // pop 当前的栈顶元素</span><br><span class="line">19:  aload_1 </span><br><span class="line">20:  areturn</span><br><span class="line">21:  astore_2</span><br><span class="line">22:  aload_0</span><br><span class="line">23:  ldc     #5; //String 22</span><br><span class="line">25:  invokevirtual   #6; //Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;</span><br><span class="line">28:  pop</span><br><span class="line">29:  aload_2</span><br><span class="line">30:  athrow</span><br></pre></td></tr></table></figure></p>
<p>跟我们前面的分析相同，21-30是处理exception的finally的代码，我们暂且不看，我们主要是看0-20行的字节码，会发现其实这段字节码，<br>跟我们分析的int的那段字节码是雷同的，同样是return的是index 1里面的数据，但是做StringBuffer操作的是index 0的数据，那么为什么<br>这段返回的”1122”呢？</p>
<p>原因在于这个astore指令了，这个指令跟istore不同这处在于，它存储的objectref的这种类型(有2种objectref类型，一种是reference, 另外一种是returnAddress)的数据，看到存的是reference，或许你已经明白为什么了，我们修改了index 0里面的reference值，自然就反应到存着相同reference的index 1里面去了，所以我们返回的值会是 “1122”.</p>
<h1 id="Summary">Summary</h1><p>这次给大家带来的是关于，try-finally的代码的分析，希望大家对于try-finally有更深刻的认识, 并且可以认识一些基本的<br>jvm的指令.下面是关于这篇文章的引用到资源来源：</p>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html" target="_blank" rel="external">1. Compiling finally</a></p>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" target="_blank" rel="external">2. The Structure of the Java Virtual Machine</a></p>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="external">3. The Java Virtual Machine Instruction Set</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/05/java-fianlly-return/" data-id="cieptkbdx000h1p04a4ntffke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-concurrency-threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/30/java-concurrency-threadlocal/" class="article-date">
  <time datetime="2014-03-30T07:14:03.000Z" itemprop="datePublished">2014-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/30/java-concurrency-threadlocal/">从零单排 Java Concurrency, ThreadLocal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是介绍Java Concurrent一系列文章的第二篇，主要会给大家带来的是ThreadLocal.</p>
<h1 id="Thread_Confinement_(线程封闭)">Thread Confinement (线程封闭)</h1><p>当我们需要共享，那些mutable的数据就需要用到同步. 有一个简单的方法避免同步就是我们不共享了。<br>如果我们每个线程都有自己的数据，那么我们就不需要同步了，这就叫做线程封闭。对于线程封闭，我们很容易想到的<br>就是栈封闭(Stack Confinement), 每个线程都有自己的栈，并且其他线程不能进入，所以在栈上面创建的数据都是封闭的，安全的。<br>我们这里会介绍另一种Java提供的线程封闭—-ThreadLocal.</p>
<h1 id="ThreadLocal的用法">ThreadLocal的用法</h1><p>ThreadLocal给我们提供的是线程自己内部的变量，基本是初始化的时候copy一份变量进入内部，以后每个线程都可以独立修改<br>自己的copy,并且不会和其他线程的copy产生冲突。通常我们会用ThreadLocal来保存那些共享的单例或者全局变量。<br>下面我们来看一段ThreadLocal的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalRuannble</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Local is "</span> + ThreadId.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们这里重点看下ThreadLocal的protected T initialValue()这个方法，这个方法return的值，就是我们为<br>当前线程准备的初始化值。当一个线程调用了ThreadLocal get()方法时，发现没有初始值，就会调用这个方法设置。<br>这个initialValue方法最多被调用一次对于每个线程，除非你调用了remove(),接着get(), initialValue会被再次调用。</p>
<p>ThreadLocal的变量应该是static的，如果ThreadLocal是实例级别的，那就真的成了”每个线程一个ThreadLocal实例”，这并不是我们想要的，<br>我们通常的做法是让ThreadLocal是个单例，它可以为我们提供一个Thread-Local的变量给我们用当前Thread使用。</p>
<p>每个线程都会隐私的含有一个Thread-Local变量的reference, 一直到拥有Thread-Local reference这个线程死去并且ThreadLocal本身就不可达了, 这个reference才会被回收。看了下ThreadLocal的代码，你会发现你的initialValue返回值，被放入一个ThreadLocalMap里面，这个ThreadLocalMap<br>是被Thread所有，并且这个Map里面的Entry是ThreadLocal和你的value组成，但是这个Entry是weakReference, 意识说</p>
<ul>
<li>要么你的Thread释放，它所拥有的ThreadLocalMap被释放了，这时候Thread-Local变量也就被释放掉</li>
<li>如果你Thread无法释放(创建Thread是非常昂贵的，所以一般的做法是把线程池的线程Interrupt),所以我们只能等GC了，<br>因为一般你用ThreadLocal估计是单例用，所以只能等GC,来回收ThreadLocalMap里面的weakRerference的Entry，这时候Thread-Local变量就被释放掉了。</li>
</ul>
<h1 id="ThreadLocal应用场景">ThreadLocal应用场景</h1><p>从上面的介绍我们已经了解到ThreadLocal的基础知识，那我们什么场景会用到ThreaLocal呢？<br>从目前来看，主要的场景的可能就是独立ID系列，jdbc connection，以及context.</p>
<ul>
<li>独立ID系列，就是指这些跟线程关系不大，几乎是各个线程不一样的。比如说我们的TransationID，我可以每个线程都有个自己工作的<br>TransationID，然后再用这个TransationID搞些事情出来，类似情况还有UserID。</li>
<li>JDBC Connection, 因为JDBC connection是线程不安全的，一个多线程的应用共享一个全局的connection不加保护肯定也是不安全的。<br>这时候我们就可以靠我们的ThreadLocal来存储JDBC connection, 这样每个线程都会有自己的connection.</li>
<li>上下文，如果context对于每个线程来说是独立的，比如说我有一个分析的引擎的context, 里面存在我们分析的内容的路径，分析的结果，<br>分析的条件，甚至加上线程级别的cache. 这样我向多线程来跑起来分析数据的时候，有了这个context不仅方便了存储，而且<br>还是线程安全的。</li>
</ul>
<h1 id="ThreadLocal的原理">ThreadLocal的原理</h1><p>可能大家已经想到了实现ThreadLocal的方法，就是为每个线程开启一个存储自己内容的map, 这样就简单实现了线程封闭, 来我们看看ThreadLocal是如何实现这个的吧。</p>
<img src="/images/ThreadLocal.png" class="center" width="600" height="300">
<p>我们可以看到当我们第一次调用get()的时候, 我们会去调用setInitialValue(), 这时候它就调用一个非常主要的方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法里面我们就创建了我们的ThreadLocal变量的holder的ThreadLocalMap, 这里注意的地方有两点：</p>
<ul>
<li>注意这个map存的地方，它是存在的当前线程里面的，而不是我们ThreadLocal里面的，所以这样的达到了每个线程有自己独有的变量map</li>
<li>这个ThreadLocalMap, 里面真正存数据的其实是一个table, 是一个数组。当我们要从我们当前线程的ThreadLocalMap里面取出内容的时候，<br>我们是把当前的调用的get()方法的ThreadLocal传人进去，然后根据每个ThreadLocal的threadLocalHashCode(这个值会随着ThreadLocal的实例的创建而增大), 做偏移去table数组里面去查找。是数组当然是有大小的，默认大小是16.</li>
</ul>
<h1 id="Summary">Summary</h1><p>本次给大家带来的主要是ThreadLocal相关的内容，更希望大家能在我说的那些场景用到ThreadLocal, 也可以通过看源代码来熟悉<br>ThreadLocal的用法，建议可以容器相关的代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/30/java-concurrency-threadlocal/" data-id="cieptkbe2000j1p04fyn7ao5v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-concurrent-basic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/23/java-concurrent-basic/" class="article-date">
  <time datetime="2014-03-23T05:59:40.000Z" itemprop="datePublished">2014-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/23/java-concurrent-basic/">从零单排 Java Concurrency, 基础篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是介绍Java Concurrent一系列文章的第一篇，会给大家带来的是一些并发的基础知识，<br>以及并发给我们带来的好处和一些问题，以及问题解决方案.</p>
<h1 id="Concurrency(并发)_&amp;_Parallelism(并行)">Concurrency(并发) &amp; Parallelism(并行)</h1><p>首先我们遇到的第一个问题就是什么是Concurrent(并发)?<br>并发: 一个处理器”同时”处理多个任务。在一个单核系统上处理多线程，处理器调度其他资源去执行其他线程，我们总不希望一直去等待一个I/O操作。就好像一个魔术师可能同时操作N个<br>球，但是你明明知道他就只是一个人。</p>
<p>那么什么是Parallelism(并行)?</p>
<p>并行: 多个处理器”同时”处理多个任务。在一个多核的系统上处理多线程，每个线程都能跑在一个<br>处理器上在一时刻。就好像N个魔术师操作N个球，同时每个人操作一个球。</p>
<p>就像大神”Rob Pike”说的那样”Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.” Concurrency对于我们编码有有一定的要求，因为我们是自己构造一种解决方案为了<br>能够”同时”处理多个任务。</p>
<h1 id="Concurrency(并发)_好处和问题">Concurrency(并发) 好处和问题</h1><p>最大的好处我认为是，并发让我们减少了单个任务的等待时间。特别表现在I/O上，如果当我们去写一个超大的文件时，<br>总不能让闲下来的那些家伙没事做呀。如果一个server只能同一时间处理一个请求，而让其他请求等待，那么就没有人愿意上网了。<br>当我们有多个CPU核的时候，Concurrency(并发)就可以让我们充分利用其资源了。<br>问题也同样也来了，主要是指多线程并发带来的问题：<br><br></p>
<ul>
<li><p>访问冲突，因为内存都是共享的，多个线程都可以访问同一块内存地址，如果我们不好好控制，冲突就会发生，<br>最突出的问题，在于各个线程读到了脏数据。</p>
</li>
<li><p>锁竞争问题，有了冲突，我们就要去保护共享的内容，通常的做法，就是给共享内容加上锁。锁带给我们的问题，<br>主要是2个，一个是死锁，A thread 等待B thread释放资源，但是B却一直在等待A释放资源，这样的结果就导致<br>资源永远释放不到，最后机器崩溃掉。另外一个显著问题是锁的粒度问题，比如说一段cache代码，他从数据库取数据<br>就开始加锁，一直到更新cache结束。这样会有什么问题呢？锁的粒度太大了，居然把去取数据的操作也加锁了，导致<br>非常多的线程在等待，最坏结果就机器响应速度下降，内存被撑爆。</p>
</li>
<li><p>上下文切换，内存拷贝的开销，这些都会使得性能下降，</p>
</li>
</ul>
<p>问题与好处并存，就使得我们在编写concurrency代码时，要时刻小心，时刻问下自己会不会发生上面的问题。</p>
<h1 id="线程安全">线程安全</h1><p>下面我们就介绍一下我们是怎样保证线程安全的。</p>
<h2 id="Java_内存模型">Java 内存模型</h2><p>在介绍线程安全之前，我们有必要了解下Java内存模型是怎么样的，只有知道了内存模型，我们才知道我们如何保证多线程下<br>访问内存是安全的.</p>
<img src="/images/Java-Memory-Model.png" class="center">
<p>Java 规定了每个thread都可以有个Work Memory, Main Memory就是我们用-Xmx指定的Heap的大小，<br>当线程需要从Main Memory读取某个变量的时候，线程就用load指令来完成，线程如果修改了这个变量，<br>那么线程就会用save指令把这个变量重写到Main Memory里面，这里我们就会发现问题了，当我们多个线程<br>操作同一个变量的时候就会出现问题。这时候我们就需要用到一些策略来保证数据的可见性和原子性。</p>
<h2 id="Happen-Before_原则">Happen-Before 原则</h2><p>指令重排，就是指指令执行顺序可能会与代码的顺序不一致，为什么需要指令重排，指令重排意义在于： JVM能够根据处理器的特征(CPU的多级缓存系统)<br>适当的重新排列机器指令，使得机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p>
<p>就算指令重排了，我们也要利用一些原则来保证某些事件之间的关系，这样才让我们实现线程安全。这就是Happen-before原则</p>
<ul>
<li>同一个线程中的每个Action都happens-before于出现在其后的任何一个Action.</li>
<li>对象监视器的解锁发生在等待获取该锁的线程获得锁之前</li>
<li>volatile变量写入操作happens-before该变量后一个读取。</li>
<li>如果A action happens-before B action, 而 B action happens-before C action, 那么A action 一定happens-before C action.</li>
</ul>
<p>我们就可以利用Happens-before原则，来保证我们线程安全性，<br>Java 提供了一些工具保证Happens-before原则, 如： synchronized, volatile, final, 和 java.util.concurreny包下面的工具。</p>
<p>这些工具的基础就是Memory Barrier(内存屏障), 内存屏障是一组屏障指令让CPU或者编译器，强制要求某些操作必须发生在屏障之前，<br>而其他操作必须发生在屏障之后，这样上层就可以利用内存屏障来实现Happens-before.</p>
<h2 id="变量可见性问题">变量可见性问题</h2><p>下面有一段代码，我们可以想想到底这段代码会打印什么样的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visibility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WorkThread().start();</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>打印 1，这是很容易想到的一个结果，主线程修改了result = 1, WorkThread读到这样的值，然后打印出来。</li>
<li>打印 0，为什么是0呢？ 想想我们的代码重排，很有可能ready = true就被派到了result = 1之前，这时候WorkThread<br>正好读到ready = true, 输出result 0.</li>
<li>一直不退出，可能有些同学已经想到了原因，当WorkThread把ready load进自己的work memory之后，就不去读main memory里面<br>已经被更新的值，所以就一直不退出。</li>
</ul>
<p>这就是变量可见性的问题，多个线程能否都能查看的main memory里的变量的变化。</p>
<h1 id="volatile_&amp;_锁_&amp;_concurrentHashMap">volatile &amp; 锁 &amp; concurrentHashMap</h1><p>上面那个变量可见性的问题，我们就可以通过volatile 来设置给ready, 这样就可以保证程序一定会退出。<br>volatile的原理</p>
<ul>
<li>volatile是轻量级的同步，Java内存模型不会对volatile指令进行重排，这个保证了对volatile变量的操作时按照指令出现<br>顺序执行的。</li>
<li>volatile的变量不会被放到CPU cache里面的，每次总是从main memory读取volatile变量的结果，所以其他线程总是可以看见<br>这个修改，并不是使用自己Thread work memory里面的。</li>
<li>volatile保证变量的可见性，但是没有保证原子性.</li>
</ul>
<p>Java 锁机制， Java 提供了很多锁， sychronized block, object.lock(), reentrantLock(可重入锁), Semaphore(信号量),<br>CAS(乐观锁)。<br>在这里主要介绍一些sychronized block的内容，当我们sychronized的一个setter方法了，另外个线程还可以get吗？<br>是不行的，因为我们给一个instance method加锁的时候，就是对于这个object加锁了。那当我们对于一个static 方法加锁的时候，<br>又是给什么加锁呢？这时候我们就是为这个class加了锁。</p>
<p>ConcurrentHashMap, 我们知道Hashmap是不安全，HashTable是线程安全的，那为什么需要ConcurrentHashMap?<br>因为HashTable实现太简单了，直接给整个table加上锁，这样所的粒度比较大，性能肯定会差，ConcurrentHashMap就是<br>利用降低锁的粒度来完成，ConcurrentHashMap会有多个segment, 每个segment下面才是多个key-value HashEntry组合，这样<br>对于某些key的锁，就可以加在它相应的segment上面了，从而降低了锁的粒度，这样就只能保证了弱一致性，各个线程看到的<br>map里面数据是不一定一致的。</p>
<p>这里只是简单的介绍了下sychronized block和ConcurrentHashMap, 以后的文章中会对锁和还有java.util.concurrent包下面的工具<br>做详细的讲解。</p>
<h1 id="Summary">Summary</h1><p>这篇blog主要是为大家带来concurrency的含义，以及它的好处，和相应的问题，在我看来好处就是提高性能，问题就是增加<br>我们编码的难度，需要思考的东西变多。接下来是关于Java Concurreny的一些topic, Java的main memory 和 work memory,<br>以及保证concurrency的happens-before原则，以及Java给我们带来的控制并发的工具volatile，锁以及concurrent包，接下来<br>会给大家带来concurrency的一些实践。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/23/java-concurrent-basic/" data-id="cieptkbcf00001p04q4k4vz34" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/08/16/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/03/30/kafka-in-action-1/">Kafka In Action 1</a>
          </li>
        
          <li>
            <a href="/2015/03/16/java-concurrency-concurrentskiplistmap/">从零单排 Java Concurrency, SkipList&amp;ConcurrnetSkipListMap</a>
          </li>
        
          <li>
            <a href="/2014/06/24/wait-notify/">从零单排 Java concurrency, wait &amp; notify</a>
          </li>
        
          <li>
            <a href="/2014/05/12/synchronized-and-lock/">从零单排 Java Concurrency, Synchronized and Lock</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Reg Wang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>